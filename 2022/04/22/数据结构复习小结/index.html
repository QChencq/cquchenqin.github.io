<!DOCTYPE html>
<html lang="zh">
<head>
    <meta charset="UTF-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="renderer" content="webkit">
    <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
    <meta name="google-site-verification" content="TZE0rZyIqLl10trYu3BWBWa1Vmz6HFwhb2OcNEK4u-s" />
     <link rel="shortcut icon" href= /img/favicon.ico >
    <title>
        Computer learning materials
    </title>
    <meta name="description" content= 嘿，我是刘训灼～这是我的子站，用于展示写的Hexo主题：Coder。欢迎访问！ >
    <meta name="keywords" content= Blog,Hexo,Theme,刘训灼,LiuXunzhuo >
    
<link rel="stylesheet" href="/libs/highlight/styles/monokai-sublime.css">

    
<link rel="stylesheet" href="/libs/font-awesome/css/font-awesome.min.css">

    
<link rel="stylesheet" href="/css/style.css">

<meta name="generator" content="Hexo 6.1.0"></head>
<body id="bodyx">
    <div class="hd posts">
    <a href="/index.html"><i class="fa fa-home
 replay-btn" aria-hidden="true"></i></a>
    <div class="post-title">
        <p>
            data structure
        </p>
        <hr>
    </div>
    <div class="post-content">
        <h1 id="数据结构复习小结"><a href="#数据结构复习小结" class="headerlink" title="数据结构复习小结"></a>数据结构复习小结</h1><h2 id="算法的渐近分析"><a href="#算法的渐近分析" class="headerlink" title="算法的渐近分析"></a>算法的渐近分析</h2><h3 id="重要区别"><a href="#重要区别" class="headerlink" title="重要区别"></a>重要区别</h3><p>上限与最坏情况的区别：</p>
<p>​	（1）上限是用来确定运行时间的增长率，体现随着输入规模变化 算法的代价变化</p>
<p>​	（2）最差情况是指：在一个给定的规模当中，所有可能的输入中最糟糕的情况。</p>
<p>​		上限规模不定，最差情况规模确定</p>
<h2 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h2><h3 id="链表"><a href="#链表" class="headerlink" title="链表"></a>链表</h3><ul>
<li><p>对单链表设置头指针的作用</p>
<p>1.简化插入删除的操作，首结点的删除不需要特殊的处理</p>
<p>2.统一了空表与非空表的操作</p>
</li>
<li><p>如何做到$O(1)$删除p结点</p>
<p>解法：不修改，直接删除p后面的结点q，将p结点的值设置为q结点的值</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">node* q=p-&gt;next;</span><br><span class="line">p-&gt;val=q-&gt;val;</span><br><span class="line">p-&gt;next=q-&gt;next;</span><br><span class="line"><span class="keyword">delete</span> q;</span><br></pre></td></tr></table></figure>
</li>
<li><p>将长度为n的单链表接在长度为m的单链表之后，时间复杂度是</p>
<p>O(m)，需要找到长度为m的单链表的尾结点</p>
</li>
<li><p>在p结点之前插入一个结点，O（1）</p>
<p>解法：将p结点设置为该值，在p结点之后插入原来的p结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> val=p-&gt;val;</span><br><span class="line">p-&gt;val=s;</span><br><span class="line">p-&gt;next=<span class="keyword">new</span> <span class="built_in">node</span>(val,p-&gt;next);</span><br></pre></td></tr></table></figure></li>
</ul>
<p>如果curr指针指向的就是当前的元素，那么我们在插入元素的时候的替代方法就是在当前元素后面插入一个点，将当前元素的值复制到新加入的点中去，然后把要插入的值加入到原来的curr指针指向的位置。</p>
<p>考虑两个问题：<br>（1）如果curr指针指向的的是链表的尾部</p>
<p>（2）是否可以连续删除</p>
<p>链表的析构函数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> (head!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">	curr=head;</span><br><span class="line">    head=head-&gt;next;</span><br><span class="line">    <span class="keyword">delete</span> curr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//构造函数</span></span><br><span class="line">head=tail=curr=<span class="keyword">new</span> <span class="built_in">Link</span>&lt;E&gt;();</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//reverse the list</span></span><br><span class="line"><span class="function">link* <span class="title">reverse</span> <span class="params">(link* head)</span></span>&#123;</span><br><span class="line">	link* curr=head-&gt;next;</span><br><span class="line">    link* new_head=curr;</span><br><span class="line">    link* p=<span class="literal">nullptr</span>;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="literal">nullptr</span>)&#123;</span><br><span class="line">		new_head=new_head-&gt;next;</span><br><span class="line">        curr-&gt;next=p;</span><br><span class="line">        p=curr;</span><br><span class="line">        curr=new_head;</span><br><span class="line">    &#125;</span><br><span class="line">    link* reverse_head=<span class="keyword">new</span> <span class="built_in">link</span>();</span><br><span class="line">    reverse_head-&gt;next=p;</span><br><span class="line">    <span class="keyword">return</span> reverse_head;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//merge two sorted list</span></span><br><span class="line"><span class="comment">//array:</span></span><br><span class="line"><span class="type">static</span> alist* res;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">merge</span><span class="params">(alist* a,alist* b)</span></span>&#123;</span><br><span class="line">    <span class="type">int</span> index_a=<span class="number">0</span>, index_b=<span class="number">0</span>;</span><br><span class="line">	<span class="keyword">while</span> (index_a!=a-&gt;<span class="built_in">size</span>()&amp;&amp;index_b!=b-&gt;<span class="built_in">size</span>())&#123;</span><br><span class="line">		<span class="keyword">if</span> (a-&gt;array[index_a]&lt;b-&gt;array[index_b])&#123;</span><br><span class="line">			res-&gt;<span class="built_in">insert</span>(a-&gt;array[index_a]);</span><br><span class="line">            index_a++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">			res-&gt;<span class="built_in">insert</span>(b-&gt;array[index_b]);</span><br><span class="line">            index_b++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index_a!=a-&gt;<span class="built_in">size</span>())&#123;</span><br><span class="line">		res-&gt;<span class="built_in">insert</span>(a-&gt;array[index_a]);</span><br><span class="line">        index_a++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (index_b!=b-&gt;<span class="built_in">size</span>())&#123;</span><br><span class="line">		res-&gt;<span class="built_in">insert</span>(b-&gt;array[index_b]);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>有尾部是单循环链表结构的const Link<E>* H,输出其相交结点的位置</p>
<p>算法流程：</p>
<ul>
<li><p>设置快慢指针，每次快指针移动两格，慢指针移动一格，二者必然相遇，并且相遇时一定在环上</p>
</li>
<li><p>此时让快指针不动，慢指针移动，记录慢指针移动的次数，二者再次相遇时所计算的次数则为圈的长度</p>
</li>
<li><p>让快慢指针同时指向头结点，快指针先走出圈的长度个格子，然后快慢指针一起移动，记录一起移动的次数，则快慢指针再次相遇时就是循环链表的长度</p>
</li>
<li></li>
</ul>
<p>双链表</p>
<p>头结点和尾结点都不储存元素（去除特殊情况，简化插入，删除操作）</p>
<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">head=curr=<span class="keyword">new</span> <span class="built_in">Link</span>&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">tail=<span class="keyword">new</span> <span class="built_in">Link</span>&lt;E&gt;();</span><br><span class="line"></span><br><span class="line">head-&gt;next=tail;</span><br></pre></td></tr></table></figure>

<h3 id="队列"><a href="#队列" class="headerlink" title="队列"></a>队列</h3><p>循环队列(maxSize&#x3D;size+1)</p>
<p>满：front&#x3D;(rear+2)%maxSize;</p>
<p>空：front&#x3D;(rear+1)%maxSize;</p>
<p>元素个数：(rear+maxSize+1-front)%maxSize;</p>
<p>顺序队列时间复杂度： O(1)</p>
<p>初始化</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">AQueue</span>(<span class="type">int</span> i)&#123;</span><br><span class="line">	maxSize=size+<span class="number">1</span>;</span><br><span class="line">	rear=<span class="number">0</span>; front=<span class="number">1</span>;</span><br><span class="line">	listArray=<span class="keyword">new</span> E[maxSize];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>链式队列头指针不存储元素</p>
<h3 id="字典"><a href="#字典" class="headerlink" title="字典"></a>字典</h3><p>实现方式：有序数组和无序数组</p>
<p>无序插入快但是查询慢，   有序插入慢但是查询快</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">二分查找：</span><br><span class="line"><span class="function">E <span class="title">find</span><span class="params">(<span class="type">const</span> Key&amp; k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> r=L.length;   <span class="comment">//二者都不指向元素</span></span><br><span class="line">	<span class="keyword">while</span> (l+<span class="number">1</span>!=r)&#123;</span><br><span class="line">		<span class="type">int</span> mid=(l+r)/<span class="number">2</span>;</span><br><span class="line">		list-&gt;<span class="built_in">moveToPos</span>(mid);</span><br><span class="line">		KVPair&lt;Key,E&gt; temp=list-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">		<span class="keyword">if</span> (k&lt;temp.key) r=mid;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (k==temp.key) <span class="keyword">return</span> temp.value;</span><br><span class="line">		<span class="keyword">else</span> l=mid;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="栈"><a href="#栈" class="headerlink" title="栈"></a>栈</h3><p>顺序栈clear()函数时间复杂度O(1)</p>
<p>应用：</p>
<h4 id="中缀表达式转换为后缀表达式"><a href="#中缀表达式转换为后缀表达式" class="headerlink" title="中缀表达式转换为后缀表达式"></a>中缀表达式转换为后缀表达式</h4><p>读入操作数的时候，立即将其放入到输出当中，操作符不立即输出，而是放入栈中</p>
<p>如果我们看到一个右括号，那么我们就从栈中弹出栈元素直到看到一个左括号，左右括号都只是被弹出而不会被输出</p>
<p>看见其他符号+，*那我们从栈中弹出元素，直到发现优先级更低的元素为止。</p>
<p>除非处理），否则不弹出（</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">converting_INfix_To_RPN</span><span class="params">(<span class="type">const</span> string&amp; exp)</span></span>&#123;</span><br><span class="line">	stack&lt;<span class="type">char</span>&gt;* op=<span class="keyword">new</span> <span class="built_in">stack</span>&lt;<span class="type">char</span>&gt;();</span><br><span class="line">	<span class="type">char</span> ch;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;exp.<span class="built_in">length</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">switch</span>(exp[i])&#123;</span><br><span class="line">			<span class="keyword">case</span><span class="number">&#x27;</span>(<span class="string">&#x27;:op-&gt;push(exp[i]); break;</span></span><br><span class="line"><span class="string">           	case&#x27;</span>)<span class="string">&#x27;: </span></span><br><span class="line"><span class="string">                while (ch=op-&gt;pop()!=&#x27;</span>(<span class="string">&#x27;) printf(&quot;ch&quot;);</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case&#x27;</span>/<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            case&#x27;</span>*<span class="string">&#x27;: while (op-&gt;length&gt;0&amp;&amp;op-&gt;top==&#x27;</span>*<span class="string">&#x27;||op-&gt;top==&#x27;</span>/<span class="string">&#x27;) printf(op-&gt;pop());</span></span><br><span class="line"><span class="string">                op-&gt;push(exp[i]);</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            case&#x27;</span>+<span class="string">&#x27;:</span></span><br><span class="line"><span class="string">            case&#x27;</span>-<span class="string">&#x27;: while (op-&gt;length&gt;0&amp;&amp;op-&gt;top!=&#x27;</span>(<span class="string">&#x27;) printf(op-&gt;pop());</span></span><br><span class="line"><span class="string">                op-&gt;push(exp[i]);</span></span><br><span class="line"><span class="string">                break;</span></span><br><span class="line"><span class="string">            default: printf(exp[i]);</span></span><br><span class="line"><span class="string">        &#125;</span></span><br><span class="line"><span class="string">	&#125;</span></span><br><span class="line"><span class="string">&#125;</span></span><br></pre></td></tr></table></figure>

<h4 id="算出后缀表达式的值"><a href="#算出后缀表达式的值" class="headerlink" title="算出后缀表达式的值"></a>算出后缀表达式的值</h4><p>如果读到一个数，放入栈中</p>
<p>如果是一个操作符，在栈中弹出两个元素，如果没有两个元素，表达式错误</p>
<p>算出值再将结果压入栈中</p>
<p>当表达式结束，结果就在栈顶</p>
<h4 id="判断出栈序列是否合法"><a href="#判断出栈序列是否合法" class="headerlink" title="判断出栈序列是否合法"></a>判断出栈序列是否合法</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">validateStackSequences</span><span class="params">(vector&lt;<span class="type">int</span>&gt;&amp; pushed, vector&lt;<span class="type">int</span>&gt;&amp; popped)</span> </span>&#123;</span><br><span class="line">        stack&lt;<span class="type">int</span>&gt; res;</span><br><span class="line">        <span class="type">int</span> index=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;pushed.<span class="built_in">size</span>();i++)&#123;</span><br><span class="line">            <span class="keyword">if</span> (popped[index]==pushed[i])&#123;</span><br><span class="line">                index++;</span><br><span class="line">                <span class="keyword">while</span> (!res.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                    <span class="keyword">if</span> (res.<span class="built_in">top</span>()==popped[index])&#123;</span><br><span class="line">                        index++;</span><br><span class="line">                        res.<span class="built_in">pop</span>();</span><br><span class="line">                    &#125;</span><br><span class="line">                    <span class="keyword">else</span>&#123;</span><br><span class="line">                        <span class="keyword">break</span>;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                res.<span class="built_in">push</span>(pushed[i]);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">while</span>(index!=popped.<span class="built_in">size</span>())&#123;</span><br><span class="line">            <span class="keyword">if</span> (res.<span class="built_in">empty</span>())&#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span> (res.<span class="built_in">top</span>()==popped[index])&#123;</span><br><span class="line">                    index++;</span><br><span class="line">                    res.<span class="built_in">pop</span>();</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span>&#123;</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="返回栈中最小值（时间复杂度O-1-）"><a href="#返回栈中最小值（时间复杂度O-1-）" class="headerlink" title="返回栈中最小值（时间复杂度O(1)）"></a>返回栈中最小值（时间复杂度O(1)）</h4><p>Hint:辅助栈</p>
<p>辅助栈存储当前的最小值，并且随着push不断更新</p>
<h4 id="符号匹配"><a href="#符号匹配" class="headerlink" title="符号匹配"></a>符号匹配</h4><p>(1)make an empty stack, read the characters until the end</p>
<p>(2)if the character is an opening symbol, push it onto the stack</p>
<p>(3)if it is a closing symbol, then if the stack is empty report the error</p>
<p>else pop the stack</p>
<p>(4)if the symbol is not the corresponding opening symbol then report an error</p>
<p>(5)at the end of file, if the stack is not empty,  report the error</p>
<h4 id="两个栈实现队列"><a href="#两个栈实现队列" class="headerlink" title="两个栈实现队列"></a>两个栈实现队列</h4><p>插入时元素依次入栈</p>
<p>如果需要出队，此时查询另一个栈</p>
<p>（1）如果该栈有元素，则弹出</p>
<p>（2）如果没有，则将原来的栈全部清空，将元素依次插入另一个栈，插入完成弹出栈顶元素</p>
<h4 id="两个队列实现栈"><a href="#两个队列实现栈" class="headerlink" title="两个队列实现栈"></a>两个队列实现栈</h4><p>插入元素时依次加入队列</p>
<p>如果需要弹出栈顶元素，则将非空队列不断弹出元素，放入另一个队列，直到只剩一个元素时停止，使其出队而不入队。该元素就是需要弹出的栈顶元素</p>
<h2 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><p>深度：根节点到M的路径长度；</p>
<p>高度：最深结点的深度+1；</p>
<p>满二叉树：每一个结点或者是分支结点（至少有一个非空子树），并恰好有两个非空子节点，或者是叶结点。(不存在度为1的结点)</p>
<p>完全二叉树：从根节点起每一层从左到右填充，一棵高度为d的完全二叉树除了d-1层之外，每一层都是满的，底层叶节点集中在左边的若干位置上。</p>
<p>堆数据结构是完全二叉树，Huffman编码树是满二叉树</p>
<p>&#x3D;&#x3D;在二叉树的递归遍历过程中，每个结点都只访问依次且仅访问一次，所以时间复杂度是O(n)&#x3D;&#x3D;;</p>
<p>将一棵二叉树存储在数组当中时，空子树的位置上不存储元素</p>
<h3 id="满二叉树定理"><a href="#满二叉树定理" class="headerlink" title="满二叉树定理"></a>满二叉树定理</h3><p>非空&#x3D;&#x3D;满二叉树&#x3D;&#x3D;的叶节点数等于其分支结点数加1；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">证明：</span><br><span class="line">（1）数学归纳法，书上</span><br><span class="line">（2）n2+n1+n0=n;   2n2+n1=n-1;(边的数量) 由此可得 n2+1=n0;</span><br><span class="line">而因为满二叉树的分支结点都是度为2的结点，所以叶结点的个数等于分支结点+1；</span><br><span class="line">	</span><br></pre></td></tr></table></figure>

<p>一棵&#x3D;&#x3D;非空二叉树&#x3D;&#x3D;空子树的数目等于其结点数+1；</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">证明：将原来的空子树全部换成叶节点，得到的新树就变成了一棵满二叉树，并且原来的结点都是该满二叉树的内部结点，所以新树的叶结点就等于原来的节点数+1；也就是空子树的数量等于结点数+1；</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>计算二叉树中结点个数：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">count</span><span class="params">(BinNode&lt;E&gt;* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">return</span> <span class="number">1</span>+<span class="built_in">count</span>(root-&gt;left)+<span class="built_in">count</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断二叉搜索树的性质是否成立：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(TreeNode* root)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root, LONG_MAX, LONG_MIN);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">bool</span> <span class="title">check</span><span class="params">(TreeNode* root,<span class="type">long</span> upper,<span class="type">long</span> low)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;val&gt;=upper||root-&gt;val&lt;=low)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">check</span>(root-&gt;left,root-&gt;val,low)&amp;&amp;<span class="built_in">check</span>(root-&gt;right,upper,root-&gt;val);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>&#x3D;&#x3D;二叉树越接近满的程度，结构性开销所占的比例也就越低，满二叉树达到最低&#x3D;&#x3D;</p>
<p>用数组来实现&#x3D;&#x3D;完全二叉树&#x3D;&#x3D;</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Parent(r)=[(r-1)/2];</span><br><span class="line">LeftChild(r)=2r+1;</span><br><span class="line">RightChild(r)=2r+2;</span><br><span class="line">LeftSibling(r)=r-1;  //当r为偶数时</span><br><span class="line">RightSibling(r)=r+1;  //当r为奇数时</span><br></pre></td></tr></table></figure>

<p>求二叉树的高度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">(BSTNode* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> l=<span class="built_in">getheight</span>(root-&gt;left);</span><br><span class="line">	<span class="type">int</span> r=<span class="built_in">getheight</span>(root-&gt;right);</span><br><span class="line">	<span class="keyword">return</span> (l&gt;r? l:r)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">(BSTNode* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">nullptr</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	BSTNode* nodes[<span class="number">101</span>];</span><br><span class="line">	<span class="type">int</span> first=<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> last=<span class="number">-1</span>;</span><br><span class="line">	<span class="type">int</span> height=<span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> latest=<span class="number">0</span>;</span><br><span class="line">	nodes[++last]=root;</span><br><span class="line">	<span class="keyword">while</span> (first&lt;last)&#123;</span><br><span class="line">		BSTNode* temp=nodes[++first];</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;left)&#123;</span><br><span class="line">			nodes[++last]=temp-&gt;left;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (temp-&gt;right)&#123;</span><br><span class="line">			nodes[++last]=temp-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (latest==first)&#123;</span><br><span class="line">			height++;</span><br><span class="line">			latest=last;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> height;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="二叉树的非递归遍历"><a href="#二叉树的非递归遍历" class="headerlink" title="二叉树的非递归遍历"></a>二叉树的非递归遍历</h3><p>Basic idea of inorder traversal using a stack:<br>Push a node into the stack when meet it, and trabersal its left subtree, after pop this node and visit it, and then traversal its right subtree;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraverse</span><span class="params">(BinNode* root)</span></span>&#123;</span><br><span class="line">	stack &lt;BinNode*&gt; s;</span><br><span class="line">    BinNode* p=root;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>||!<span class="built_in">StackEmtpy</span>(s))&#123;</span><br><span class="line">		<span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			<span class="built_in">push</span>(s,p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!<span class="built_in">StackEmpry</span>(s))&#123;</span><br><span class="line">			p=<span class="built_in">pop</span>(s);</span><br><span class="line">            <span class="built_in">visit</span>(p-&gt;val);</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">preorder</span><span class="params">(BinNode* root)</span></span>&#123;</span><br><span class="line">	stack&lt;BinNode*&gt; s;</span><br><span class="line">    BinNode* p=root;</span><br><span class="line">    <span class="keyword">while</span> (p!=<span class="literal">NULL</span>||!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		<span class="keyword">while</span> (p!=<span class="literal">NULL</span>)&#123;</span><br><span class="line">			cout&lt;&lt;p-&gt;data&lt;&lt;endl;</span><br><span class="line">            s.<span class="built_in">push</span>(p);</span><br><span class="line">            p=p-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (!s.<span class="built_in">empty</span>())&#123;</span><br><span class="line">			p=s.<span class="built_in">top</span>();</span><br><span class="line">            s.<span class="built_in">pop</span>();</span><br><span class="line">            p=p-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Internal nodes store operators, while the leaves store operands;</p>
<p>There are two approaches:<br>（1）to use class inheritance</p>
<p>A base classs can be declared for binary tree nodes in general, with subclasses defined for internal and leaf nodes;</p>
<p>（2）to use the composite design pattern</p>
<p>using a virtual base class and separate node classes for two types;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="type">int</span> ElementType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">struct</span> <span class="title class_">TNode</span> *Position;</span><br><span class="line"><span class="keyword">typedef</span> Position BinTree;</span><br><span class="line"><span class="keyword">struct</span> <span class="title class_">TNode</span>&#123;</span><br><span class="line">    ElementType Data;</span><br><span class="line">    BinTree Left;</span><br><span class="line">    BinTree Right;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">PreorderTraversal</span><span class="params">( BinTree BT )</span></span>; <span class="comment">/* 先序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">InorderTraversal</span><span class="params">( BinTree BT )</span></span>;  <span class="comment">/* 中序遍历，由裁判实现，细节不表 */</span></span><br><span class="line"></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">( BinTree BST, ElementType X )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">( BinTree BST )</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BinTree BST, MinP, MaxP, Tmp;</span><br><span class="line">    ElementType X;</span><br><span class="line">    <span class="type">int</span> N, i;</span><br><span class="line"></span><br><span class="line">    BST = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span> ( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = <span class="built_in">Insert</span>(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Preorder:&quot;</span>); <span class="built_in">PreorderTraversal</span>(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    MinP = <span class="built_in">FindMin</span>(BST);</span><br><span class="line">    MaxP = <span class="built_in">FindMax</span>(BST);</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        Tmp = <span class="built_in">Find</span>(BST, X);</span><br><span class="line">        <span class="keyword">if</span> (Tmp == <span class="literal">NULL</span>) <span class="built_in">printf</span>(<span class="string">&quot;%d is not found\n&quot;</span>, X);</span><br><span class="line">        <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;%d is found\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MinP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the smallest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">            <span class="keyword">if</span> (Tmp==MaxP) <span class="built_in">printf</span>(<span class="string">&quot;%d is the largest key\n&quot;</span>, Tmp-&gt;Data);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;N);</span><br><span class="line">    <span class="keyword">for</span>( i=<span class="number">0</span>; i&lt;N; i++ ) &#123;</span><br><span class="line">        <span class="built_in">scanf</span>(<span class="string">&quot;%d&quot;</span>, &amp;X);</span><br><span class="line">        BST = <span class="built_in">Delete</span>(BST, X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Inorder:&quot;</span>); <span class="built_in">InorderTraversal</span>(BST); <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/* 你的代码将被嵌在这里 */</span></span><br><span class="line"><span class="function">BinTree <span class="title">Insert</span><span class="params">(BinTree BST,ElementType X)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (BST==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BinTree</span>(X,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (X&lt;BST-&gt;val)&#123;</span><br><span class="line">		BST-&gt;left=<span class="built_in">Insert</span>(BST-&gt;left,X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		BST-&gt;right=<span class="built_in">Insert</span>(BST-&gt;right,X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">Find</span><span class="params">(BinTree BST,ElementType X)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (BST==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (X&lt;BST-&gt;val)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Find</span>(BST-&gt;left,X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X&gt;BST-&gt;val)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">Find</span>(BST-&gt;right,X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> BST;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">FindMin</span><span class="params">(BinTree BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FindMin</span>(BST-&gt;left);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">Position <span class="title">FindMax</span><span class="params">(BinTree BST)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (BST==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (root-&gt;right==<span class="literal">NULL</span>) <span class="keyword">return</span> root;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">FindMax</span>(BST-&gt;right);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BinTree <span class="title">Delete</span><span class="params">(BinTree BST,ElementType X)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (BST==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (X&lt;BST-&gt;val)&#123;</span><br><span class="line">		BST-&gt;left=<span class="built_in">Delete</span>(BST,X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (X&gt;BST-&gt;val)&#123;</span><br><span class="line">		BST-&gt;right=<span class="built_in">Delete</span>(BST,X);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;  <span class="comment">//此时已经找到需要被删除的结点</span></span><br><span class="line">		<span class="keyword">if</span> (BST-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			BST=BST-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (BST-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			BST=BST-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;  <span class="comment">//有两个非空的子结点</span></span><br><span class="line">			BinTree temp=<span class="built_in">findMin</span>(BST-&gt;right);</span><br><span class="line">            BST-&gt;val=temp-&gt;val;</span><br><span class="line">            BST-&gt;right=<span class="built_in">Delete</span>(BST-&gt;right,temp-&gt;val);</span><br><span class="line">            <span class="built_in">delete</span>(temp);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> BST;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h3 id="BST"><a href="#BST" class="headerlink" title="BST"></a>BST</h3><h4 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h4><p>对于二叉搜索树的任何一个结点，设其值为K，则该结点&#x3D;&#x3D;左子树的任意一个结点&#x3D;&#x3D;的值都小于K，该结点的&#x3D;&#x3D;右子树中任意一个结点&#x3D;&#x3D;的值都大于或等于K。</p>
<p>特点：按照中序遍历将各个结点打印出来，会得到由小到大的排列的特点；</p>
<p>search: $\Theta(logn)$</p>
<p>The complexity of operations get,insert and remove in BST is $\Theta(h)$</p>
<p>so the complexity is $\Theta(logn)$when the tree is balanced;</p>
<h4 id="BST的检索"><a href="#BST的检索" class="headerlink" title="BST的检索"></a>BST的检索</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">E BST&lt;Key,E&gt;::<span class="built_in">findhelp</span>(BSTNode&lt;Key,E&gt;* root, <span class="type">const</span> Key&amp; k)<span class="type">const</span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">if</span> (k&lt;root-&gt;<span class="built_in">key</span>()) <span class="keyword">return</span> <span class="built_in">findhelp</span>(root-&gt;left,k);</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (k&gt;root-&gt;<span class="built_in">key</span>()) <span class="keyword">return</span> <span class="built_in">findhelp</span>(root-&gt;right,k);</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root-&gt;<span class="built_in">element</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BST结点的插入"><a href="#BST结点的插入" class="headerlink" title="BST结点的插入"></a>BST结点的插入</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">BSTNode&lt;Key,E&gt;* BST&lt;Key,E&gt;::<span class="built_in">inserthelp</span>(BSTNode&lt;Key,E&gt;* root, cosnt Key&amp; k, <span class="type">const</span> E&amp; it)&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">BSTNode</span>&lt;Key,E&gt;(k,it,<span class="literal">NULL</span>,<span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;val&gt;k)&#123;</span><br><span class="line">		root-&gt;left=<span class="built_in">inserthelp</span>(root-&gt;left,k,it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		root-&gt;right=<span class="built_in">inserthelp</span>(root-&gt;right,k,it);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BST结点的删除"><a href="#BST结点的删除" class="headerlink" title="BST结点的删除"></a>BST结点的删除</h4><p>BST中最小值结点的删除</p>
<p>一直向左边搜寻，如果没有左边结点，返回右边结点；否则root-&gt;left&#x3D;deletemin(root-&gt;left);</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">BSTNode&lt;Key,E&gt;* BST&lt;Key,E&gt;::<span class="built_in">deletemin</span>(BSTNode&lt;Key,E&gt;* root)&#123;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;left==<span class="literal">nullptr</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> root-&gt;right;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		root-&gt;left=<span class="built_in">deletemin</span>(root-&gt;left);</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">与inserthelp一样，在回到根节点路径上的各个节点的左指针都被重新赋值指向子树</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//找到最小值</span></span><br><span class="line">BSTNode&lt;Key,E&gt;* BST&lt;Key,E&gt;::<span class="built_in">getmin</span>(BSTNode&lt;Key,E&gt;* root)&#123;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">return</span> <span class="built_in">getmin</span>(root-&gt;left);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>删除一个结点的各种可能性：<br>（1）如果被删除结点R没有子结点，直接将R的父节点指向它的指针改为NULL</p>
<p>（2）如果只有一个子结点，将R的父节点指向它的指针改为指向它的子结点</p>
<p>（3）如果R有两个子结点，用大于（或等于）R的值中的最小者，或者小于R的值的最大者来替换R</p>
<p>findhelp与inserthelp的时间代价取决与于被找到&#x2F;插入的深度。removehelp的时间代价取决于被删除结点的深度。如果结点有两个子结点，则取决于其右子树包含的最小值结点的深度。最差情况下就是BST的深度。</p>
<p>平衡二叉树：每次插入O(log(n)),共需要O(nlogn);</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BSTNode&lt;Key,E&gt;* BST&lt;Key,E&gt;::<span class="built_in">removehelp</span>(BSTNode&lt;Key,E&gt;* root,<span class="type">const</span> Key&amp; k)&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (k&lt;root-&gt;val) root-&gt;left=<span class="built_in">removehelp</span>(root-&gt;left,k);</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (k&gt;root-&gt;val) root-&gt;right=<span class="built_in">removehelp</span>(root-&gt;right,k);</span><br><span class="line">	<span class="keyword">else</span>&#123;  <span class="comment">//此时已经找到需要被删除的点</span></span><br><span class="line">		BSTNode&lt;Key,E&gt;* temp=root;</span><br><span class="line">		<span class="keyword">if</span> (root-&gt;left==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			root=root-&gt;right;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (root-&gt;right==<span class="literal">NULL</span>)&#123;</span><br><span class="line">			root=root-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">			temp=<span class="built_in">getmin</span>(root);</span><br><span class="line">            root-&gt;val=temp-&gt;val;</span><br><span class="line">            root-&gt;right=<span class="built_in">deletemin</span>(root-&gt;right);</span><br><span class="line">            <span class="keyword">delete</span> temp;</span><br><span class="line">        &#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>不论树的结构如何，遍历二叉树的时间代价为o(n),每个结点恰好被访问一次，每个指针也恰好被引用一次。</p>
<h4 id="清除排序二叉树"><a href="#清除排序二叉树" class="headerlink" title="清除排序二叉树"></a>清除排序二叉树</h4><p>因为一个结点的子结点必须先于结点自身释放，因此这个过程是&#x3D;&#x3D;后序遍历&#x3D;&#x3D;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">clearhelp</span><span class="params">(BSTNode&lt;Key,E&gt;* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="built_in">clearhelp</span>(root-&gt;left);</span><br><span class="line">    <span class="built_in">clearhelp</span>(root-&gt;right);</span><br><span class="line">    <span class="keyword">delete</span> root;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="BST的平均查找长度"><a href="#BST的平均查找长度" class="headerlink" title="BST的平均查找长度"></a>BST的平均查找长度</h4><p>查找成功的平均查找长度为：<br>$$<br> \frac{\sum(本层高度<em>本层元素个数)}{结点总数}\<br>\<br>$$<br>查找不成功的平均查找长度为：<br>$$<br>\frac {\sum (本层高度</em>本层补上的叶子个数)}{补上的叶子总数}\<br>$$</p>
<h4 id="BST常见面试题"><a href="#BST常见面试题" class="headerlink" title="BST常见面试题"></a>BST常见面试题</h4><p>counts[]数组有如下的性质，counts[i]的值是A[i]右侧小于A[i]的元素个数；</p>
<p>解决：从后往前构造BST，counts[i]的值就是A[i]在当前BST上比它小的结点个数</p>
<p>给定一棵二叉搜索树，找到该树中两个指定结点的最近公共祖先：<br>解决：首先判断这两个结点是否都在BST的左子树上，如果都在则继续递归查找BST的左子树，如果都不在左子树上则继续递归查找右子树，如果一个在左子树，一个在右子树，则此时他们的最近公共祖先就是当前的root结点</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title class_">Solution</span> &#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="function">TreeNode* <span class="title">lowestCommonAncestor</span><span class="params">(TreeNode* root, TreeNode* p, TreeNode* q)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==p||root==q)&#123;</span><br><span class="line">            <span class="keyword">return</span> root;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="type">bool</span> isp=<span class="built_in">search</span>(root-&gt;left,p);</span><br><span class="line">        <span class="type">bool</span> isq=<span class="built_in">search</span>(root-&gt;left,q);</span><br><span class="line">        <span class="keyword">if</span> (isp&amp;&amp;isq)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;left,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (!isp&amp;&amp;!isq)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="built_in">lowestCommonAncestor</span>(root-&gt;right,p,q);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">search</span><span class="params">(TreeNode* root,TreeNode* p)</span></span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (root==<span class="literal">NULL</span>)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (root==p)&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">search</span>(root-&gt;left,p))&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">search</span>(root-&gt;right,p);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>判断是否是一棵有效的二分搜索树</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isValidBST</span><span class="params">(BSTNode* root,<span class="type">int</span> low,<span class="type">int</span> high)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;val&lt;=low||root-&gt;val&gt;=high)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">isValidBST</span>(root-&gt;left,low,root-&gt;val)&amp;&amp;<span class="built_in">isValidBST</span></span><br><span class="line">        (root-&gt;right,root-&gt;val,high);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到一棵二分搜索树的第k小的元素：中序遍历，找到第k小的元素</p>
<h3 id="AVL"><a href="#AVL" class="headerlink" title="AVL"></a>AVL</h3><p>本质：是特殊的二分搜索树，它是为了防止某一侧特别长诞生的</p>
<p>不平衡：指的是左右的高度差大于等于2；</p>
<p>通过旋转来修正</p>
<p>在一棵AVL树中，它最大深度为$\Theta(logn)$ 因此搜索与更新二分搜索树最坏情况下的时间效率为$\Theta(logn)$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//ADT for AVL</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">AVLNode</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	E element;</span><br><span class="line">	<span class="type">int</span> ht; <span class="comment">//以结点为根的子树高度</span></span><br><span class="line">	AVLNode* left;</span><br><span class="line">	AVLNode* right;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>判断不平衡</p>
<ol>
<li>比较两侧的高度</li>
<li>比较值与根的左（右）儿子值大小</li>
</ol>
<p>关键步骤</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">GetHeight</span><span class="params">(AVLNode* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	<span class="type">int</span> l=<span class="built_in">GetHeight</span>(root-&gt;left);</span><br><span class="line">	<span class="type">int</span> r=<span class="built_in">GetHeight</span>(root-&gt;right);</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">max</span>(l,r)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//右旋</span></span><br><span class="line"><span class="function">AVLNode* <span class="title">RightRotate</span><span class="params">(AVLNode* root)</span></span>&#123;</span><br><span class="line">	AVLNode* t=root-&gt;left;</span><br><span class="line">	root-&gt;left=t-&gt;right;</span><br><span class="line">	root-&gt;ht=<span class="built_in">getHeight</span>(root); <span class="comment">//更新高度</span></span><br><span class="line">	t-&gt;right=root;</span><br><span class="line">	t-&gt;ht=<span class="built_in">getHeight</span>(t);</span><br><span class="line">	<span class="keyword">return</span> t;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">AVLNode* <span class="title">LeftRotate</span><span class="params">(AVLNode* root)</span></span>&#123;</span><br><span class="line">	AVLNode* t=root-&gt;right;</span><br><span class="line">	root-&gt;right=t-&gt;left;</span><br><span class="line">	root-&gt;ht=<span class="built_in">getHeight</span>(root);</span><br><span class="line">	t-&gt;left=root;</span><br><span class="line">	t-&gt;ht=<span class="built_in">getHeight</span>(root);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>在AVL树中插入结点时，如果发生了不平衡的情况，对于最底层的不平衡结点S，有以下四种：</p>
<ul>
<li>LL：额外的结点是S的左孩子的左孩子</li>
<li>LR：额外的结点是S的左孩子的右孩子</li>
<li>RL：额外的结点是S的右孩子的左孩子</li>
<li>RR：额外的结点是S的右孩子的右孩子</li>
</ul>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">LL: </span><br><span class="line">判断条件：<span class="built_in">height</span>(root-&gt;left)-<span class="built_in">height</span>(root-&gt;right)=<span class="number">2</span> &amp;&amp; </span><br><span class="line"><span class="built_in">height</span>(root-&gt;left-&gt;left)&gt;<span class="built_in">height</span>(root-&gt;left-&gt;right);</span><br><span class="line"><span class="built_in">LL</span>(root)&#123;</span><br><span class="line">	root=<span class="built_in">RightRotate</span>(root);</span><br><span class="line">	<span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line">LR: </span><br><span class="line">判断条件：<span class="built_in">height</span>(root-&gt;left)-<span class="built_in">height</span>(root-&gt;right)=<span class="number">2</span> &amp;&amp; </span><br><span class="line"><span class="built_in">height</span>(root-&gt;left-&gt;left)&lt;<span class="built_in">height</span>(root-&gt;left-&gt;right);</span><br><span class="line"><span class="built_in">LR</span>(root)&#123;</span><br><span class="line">	root-&gt;left=<span class="built_in">LeftRotate</span>(root-&gt;left);</span><br><span class="line">	root=<span class="built_in">RightRotate</span>(root-&gt;right);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211222133036.jpg"></p>
<h3 id="堆与优先队l列"><a href="#堆与优先队l列" class="headerlink" title="堆与优先队l列"></a>堆与优先队l列</h3><h4 id="堆的性质及其定义"><a href="#堆的性质及其定义" class="headerlink" title="堆的性质及其定义"></a>堆的性质及其定义</h4><p>首先，它是一棵完全二叉树，可以通过数组来实现。其次，堆中存储的数据是局部有序的；</p>
<p>its height is guranteed to be the minimum possible. In paticular, a heap containing n nodes will have a height of  log(n+1)（向上取整）</p>
<p>最大堆：任意一个结点存储的值都大于或者等于任意一个子结点存储的值。由于根节点包含大于或者等于其子结点存储的值，而其子结点又依次大于或者等于各自子结点存储的值，所以根结点存储该树所有结点的最大值</p>
<p>最小堆：任意一个结点存储的值都小于或者等于其任意一个子结点存储的值；</p>
<p>无论最大堆还是最小堆，任何一个结点与其兄弟结点之间都没有必然的联系。</p>
<p>堆的实现</p>
<h4 id="Building-Heap"><a href="#Building-Heap" class="headerlink" title="Building Heap"></a>Building Heap</h4><p>第i层的结点数目为$2^i$,前i层的数目是$2^{i+1}-1$</p>
<p>一个有n个结点的堆的高度是$log(n+1)$向上取整</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">shiftdown</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!<span class="built_in">isLeaf</span>(pos))&#123;</span><br><span class="line">		<span class="type">int</span> j=<span class="built_in">leftchild</span>(pos); <span class="type">int</span> rc=<span class="built_in">rightchild</span>(pos);</span><br><span class="line">        <span class="keyword">if</span> ((rc&lt;n)&amp;&amp;Comp::<span class="built_in">prior</span>(Heap[rc],Heap[j]))&#123;</span><br><span class="line">			j=rc;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (Comp::<span class="built_in">prior</span>(Heap[pos],Heap[j])) <span class="keyword">return</span> ;</span><br><span class="line">        <span class="built_in">swap</span>(Heap.pos,j);</span><br><span class="line">        pos=j;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>如果实现的是最大堆找的是左子树和右子树的最大值，然后比较根结点和这个最大值的大小，如果根结点的值小于最大值，则交换根节点和j;</p>
<p>Each siftdown operation can cost at most the number of levels it take for the node being sifted to reach the bottom of the tree</p>
<p>So,  this algotithm takes O(n) time in the worst case;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">buildHeap</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=n/<span class="number">2</span><span class="number">-1</span>;i&gt;=<span class="number">0</span>;i--)&#123;</span><br><span class="line">		<span class="built_in">shiftdown</span>(i);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>因此在最差情况下该算法的复杂度为O（n）;</p>
<h4 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h4><p>每次将结点插入数组的最后一个，然后再将该结点shiftup到正确的位置</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">insert</span><span class="params">(<span class="type">const</span> E&amp; it)</span></span>&#123;</span><br><span class="line">	<span class="built_in">Assert</span>(n&lt;maxSize,<span class="string">&quot;Heap is full&quot;</span>);</span><br><span class="line">    <span class="type">int</span> curr=n++;</span><br><span class="line">    Heap[curr]=it;</span><br><span class="line">    <span class="keyword">while</span> (curr!=<span class="number">0</span>&amp;&amp;Comp::<span class="built_in">prior</span>(Heap[curr],Heap[parent[curr]]))&#123;</span><br><span class="line">		<span class="built_in">swap</span>(Heap,curr,parent[curr]);</span><br><span class="line">        curr=parent[curr];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Each call to insert takes O(log(n)) time in the worst case, bacause the value being inserted can move at most the distance from the bottom of the tree to the top of the tree.</p>
<p>建立堆的两种方式</p>
<p>（1）一个一个的插入堆中</p>
<p>（2）通过交换的方式建堆，首先先将子树成堆，只需要将ROOT结点向下推，即调用siftdown(root); 建堆算法是从数组中部的第一个分支结点开始的；</p>
<h4 id="Heap-removal"><a href="#Heap-removal" class="headerlink" title="Heap removal"></a>Heap removal</h4><p>removing the maximum value from a heap containg n elements requires</p>
<p>（1）maintain the complete binary tree shape</p>
<p>by moving the element in the last position in the heap(the currnet last element in the heap) to the root position</p>
<p>（2）the remaining n-1 nodes values conform to the heap property.</p>
<p>If the new root value is not the maximum value in the new heap, ues the siftdown to reorder the heap;</p>
<p>the cost of deleting the maximum element is O(logn) in the average and worst cases, sice the heap is log(n) levels deep;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">E <span class="title">removefist</span><span class="params">()</span></span>&#123;</span><br><span class="line">	<span class="built_in">Assert</span>(n&gt;<span class="number">0</span>,<span class="string">&quot;Heap is empty&quot;</span>);</span><br><span class="line">	<span class="built_in">swap</span>(Heap,<span class="number">0</span>,--n);</span><br><span class="line">	<span class="keyword">if</span> (n!=<span class="number">0</span>) <span class="built_in">siftdown</span>(<span class="number">0</span>);</span><br><span class="line">	<span class="keyword">return</span> Heap[n];</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">E <span class="title">remove</span><span class="params">(<span class="type">int</span> pos)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (pos==n<span class="number">-1</span>) n--;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="built_in">swap</span>(Heap,pos,--n);</span><br><span class="line">        <span class="keyword">while</span> ((pos!=<span class="number">0</span>)&amp;&amp;(Comp::<span class="built_in">prior</span>(Heap[pos],Heap[parent[pos]]]))&#123;</span><br><span class="line">			<span class="built_in">swap</span>(Heap,pos,parent[pos]);</span><br><span class="line">            pos=parent[pos];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (n!=<span class="number">0</span>) <span class="built_in">siftdown</span>(pos);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> Heap[n];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="Huffman编码树"><a href="#Huffman编码树" class="headerlink" title="Huffman编码树"></a>Huffman编码树</h3><p>满二叉树</p>
<p>其目的在于按照最小外部路径权重建立一棵树。一个叶结点加权路径长度定义为权重乘以深度</p>
<p>具有最小外部路径权重的二叉树就是，对于给定的叶节点集合，具有加权路径长度之和最小的二叉树，即权重大的叶结点深度小。</p>
<p>Huffman树的内部结点和叶节点包含不同的信息</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">HuffTree&lt;E&gt;* <span class="title">buildHuff</span><span class="params">(HuffTree&lt;E&gt;** TreeArray,<span class="type">int</span> count)</span></span>&#123;</span><br><span class="line">	heap&lt;HuffTree&lt;E&gt;*,minTreeComp&gt; forest=<span class="keyword">new</span> heap&lt;HuffTree&lt;E&gt;*,minTreeComp&gt;(TreeArray,count,count);</span><br><span class="line">    HuffTree&lt;E&gt;* temp1,temp2,temp3=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (forest-&gt;size&gt;<span class="number">1</span>)&#123;</span><br><span class="line">		temp1=forest-&gt;<span class="built_in">removefirst</span>();</span><br><span class="line">        temp2=forest-&gt;<span class="built_in">removefirst</span>();</span><br><span class="line">        temp3=<span class="keyword">new</span> <span class="built_in">HuffTree</span>&lt;E&gt;(temp1,temp2);</span><br><span class="line">        forest-&gt;<span class="built_in">insert</span>(temp3);</span><br><span class="line">        <span class="built_in">delete</span>(temp1);</span><br><span class="line">        <span class="built_in">delete</span>(temp2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> temp3;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Huffman树的方法是贪心算法的一个例子，每一步中，权重最小的两棵子树结合成一棵新的子树；</p>
<p>一组代码中任何一个代码都不是另一个代码的前缀，则称其具有前缀性(prefix property)</p>
<p>预计平均每个字母的代码长度等于每个代码的长度(c<del>i</del>)乘以其出现的概率(p<del>i</del>),即<br>$$<br>c_1p_1+c_2p_2+…+c_np_n<br>$$<br>也可以记为<br>$$<br>\frac{c_1f_1+c_2f_2+…+c_nf_n}{f_T}<br>$$<br>f<del>i</del>表示第i个字母的相对频率，f<del>T</del>表示所有字母的总频率；</p>
<p>带权路径长度记为<br>$$<br>WPL&#x3D;\sum权值*路径长度<br>$$</p>
<h2 id="树"><a href="#树" class="headerlink" title="树"></a>树</h2><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通树的定义</span></span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="keyword">class</span> <span class="title class_">GTNode</span>&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">	<span class="function">E <span class="title">value</span><span class="params">()</span></span>&#123;&#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">isLeaf</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">GTNode* <span class="title">parent</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">GTNode* <span class="title">leftmostChild</span><span class="params">()</span></span>;</span><br><span class="line">    <span class="function">GTNode* <span class="title">rightSibling</span><span class="params">()</span></span>;  </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通树的先根遍历</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">printhelp</span><span class="params">(GTNode&lt;E&gt;* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root-&gt;<span class="built_in">isLeaf</span>()) cout&lt;&lt;<span class="string">&quot;Leaf: &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span> cout&lt;&lt;<span class="string">&quot;Internal: &quot;</span>;</span><br><span class="line">    <span class="keyword">for</span> (GTNode&lt;E&gt;* temp=root-&gt;<span class="built_in">leftmostChild</span>();temp!=<span class="literal">NULL</span>;temp=temp-&gt;<span class="built_in">rightSibling</span>())&#123;</span><br><span class="line">		<span class="built_in">printhelp</span>(temp);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="树的几种实现方法"><a href="#树的几种实现方法" class="headerlink" title="树的几种实现方法"></a>树的几种实现方法</h3><h4 id="父指针表示法"><a href="#父指针表示法" class="headerlink" title="父指针表示法"></a>父指针表示法</h4><p>每个结点只保存一个指针域，指向其父节点；</p>
<p>缺点：找到一个结点的最左子结点或者右兄弟结点操作无法实现<br>可以解决问题：给定两个结点，是否在同一棵树中;</p>
<p>轻松降低树高度的途径：加权合并规则（weighted union rule）</p>
<p>把结点较少的一棵树与结点较多的一棵树归并时，把结点较少的树指向结点较多树的根结点；这样可以把树的整体深度限制在O(log n);</p>
<p>路径压缩方法是一种可以产生极浅树的方法</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">find</span><span class="params">(<span class="type">int</span> curr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (array[curr]==curr) <span class="keyword">return</span> curr;</span><br><span class="line">	<span class="keyword">else</span>&#123;</span><br><span class="line">		array[curr]=<span class="built_in">find</span>(array[curr]);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> array[curr];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="子结点表示法"><a href="#子结点表示法" class="headerlink" title="子结点表示法"></a>子结点表示法</h4><p>每个分支结点都存储其子结点形成一个链表</p>
<p>子结点表示法在数组中存储树的结点。每个结点包括结点值，一个父指针以及一个指向子结点链表的指针</p>
<p>缺点：（1）查找一个子结点的右兄弟结点时，最差情况下需要遍历所有的子结点链表；</p>
<p>（2）如果两棵树存储在不同的数组，则难以合并；</p>
<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211217165636.jpg"></p>
<h4 id="左子结点-x2F-右兄弟结点表示法"><a href="#左子结点-x2F-右兄弟结点表示法" class="headerlink" title="左子结点&#x2F;右兄弟结点表示法"></a>左子结点&#x2F;右兄弟结点表示法</h4><p>每个结点存储结点的值，以及指向父结点的指针，最左子结点，右兄弟结点的指针。</p>
<p>合并树的操作：只需要改变三个指针操作：</p>
<p>（1）合并后成为子树的树的根结点的parent指针；</p>
<p>（2）合并后成为子树的树的根结点的right指针（可能）；</p>
<p>（3）新的根结点的最左子结点（可能）；</p>
<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211217165721.jpg"></p>
<h4 id="动态结点表示法"><a href="#动态结点表示法" class="headerlink" title="动态结点表示法"></a>动态结点表示法</h4><p>为每个结点分配可变的存储空间</p>
<p>（1）把一个指向子结点的指针数组作为结点的一部分分配给该结点</p>
<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211217165751.jpg"></p>
<p>（2）每个结点存储一条子结点链表</p>
<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211217170044.jpg"></p>
<h3 id="将树转换为二叉树"><a href="#将树转换为二叉树" class="headerlink" title="将树转换为二叉树"></a>将树转换为二叉树</h3><p>（1）将树的根结点直接作为二叉树的根结点；</p>
<p>（2）在所有的兄弟结点之间加一条线；</p>
<p>（2）对每个结点，除了保留与其长子的连线之外，去掉该结点与其他孩子的结点</p>
<p>将结点的孩子放在左子树，结点的兄弟放在右子树；</p>
<h3 id="将森林转换为二叉树"><a href="#将森林转换为二叉树" class="headerlink" title="将森林转换为二叉树"></a>将森林转换为二叉树</h3><p>（1）先把每棵树转换为二叉树</p>
<p>（2）第一棵二叉树不动，从第二棵二叉树开始，依次把后一棵二叉树的根结点作为前一棵二叉树的根结点的右孩子结点；</p>
<h3 id="将二叉树转换为树"><a href="#将二叉树转换为树" class="headerlink" title="将二叉树转换为树"></a>将二叉树转换为树</h3><p>（1）若某结点的左孩子结点存在，将左孩子结点的右孩子结点，右孩子结点的右孩子结点…都转换为该结点的孩子结点，将该结点与这些右孩子结点用线连接起来；</p>
<p>（2）删除原二叉树中所有的结点与其右孩子结点的连线；</p>
<p>（3）整理，使其层次分明;</p>
<h3 id="将二叉树转换为森林"><a href="#将二叉树转换为森林" class="headerlink" title="将二叉树转换为森林"></a>将二叉树转换为森林</h3><p>（二叉树有右孩子）</p>
<p>（1）从根结点开始，如果右孩子存在，则把与右孩子的结点的连线删除；</p>
<p>（2）将每棵分离后的二叉树转换为树；</p>
<h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><p>matrices</p>
<p>&#x3D;&#x3D;Row-major order&#x3D;&#x3D;: the address of a<del>ij</del> will be obtained as<br>$$<br>Address(a_{ij})&#x3D;M+(i-1)*n+j-1<br>$$<br>&#x3D;&#x3D;Column-major&#x3D;&#x3D; order:the fromula will stand as<br>$$<br>Address(a_{ij})&#x3D;M+(j-1)*n+i-1<br>$$</p>
<h3 id="对称矩阵"><a href="#对称矩阵" class="headerlink" title="对称矩阵"></a>对称矩阵</h3><p>k&#x3D;i*(i-1)&#x2F;2+j-1  i&gt;&#x3D;j;</p>
<p>k&#x3D;j*(j-1)&#x2F;2+i-1  i&lt;j;</p>
<h3 id="三角矩阵"><a href="#三角矩阵" class="headerlink" title="三角矩阵"></a>三角矩阵</h3><p>upper triangular matix: its nonzero elements are found only in the upper triangle of the matrix, including the main diagonal</p>
<p>下三角矩阵的存储方式和对称矩阵一致；</p>
<p>&#x3D;&#x3D;下三角矩阵压缩的方式是将上三角的元素全部压缩至一个位置，所以需要的空间为(n)*(n+1)&#x2F;2+1;&#x3D;&#x3D; 并且上三角压缩后的元素位置是在最后一个</p>
<h3 id="Symmetric-Band-Matrix"><a href="#Symmetric-Band-Matrix" class="headerlink" title="Symmetric Band Matrix"></a>Symmetric Band Matrix</h3><p>it is a symmetric band matrix is a symmetric matric whose nonzero elements are arranged uniformly near the diagonal,</p>
<p>a<del>ij</del> is equal to 0(if |i-j| is greater than k, where k is the half band width)</p>
<p>tranpose a matrix</p>
<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211221211535.jpg"></p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">tranpose</span><span class="params">(term a[],term b[])</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> n,i,j,currentb;</span><br><span class="line">    n=a[<span class="number">0</span>].value;</span><br><span class="line">    b[<span class="number">0</span>].row=a[<span class="number">0</span>].col;</span><br><span class="line">    b[<span class="number">0</span>].col=a[<span class="number">0</span>].row;</span><br><span class="line">    b[<span class="number">0</span>].value=n;</span><br><span class="line">    <span class="keyword">if</span> (n&gt;<span class="number">0</span>)&#123;</span><br><span class="line">		currentb=<span class="number">1</span>;</span><br><span class="line">     	<span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;a[<span class="number">0</span>].col;i++)&#123;<span class="comment">//为了保证转置之后row可以升序</span></span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (a[j].col==i)&#123;</span><br><span class="line">					b[currentb].row=i;</span><br><span class="line">                    b[currentb].col=a[j].row;</span><br><span class="line">                    b[currentb].value=a[j].value;</span><br><span class="line">                    currentb++;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//O(columns*elements)</span></span><br></pre></td></tr></table></figure>



<h2 id="图"><a href="#图" class="headerlink" title="图"></a>图</h2><p>无向图的最大连通子图称为连通分量；</p>
<p>Simple paths and Cycles</p>
<p>a simple path repeats no vertices(except the first can be the last.);</p>
<p>a cycle is a path that starts and ends at the same node;</p>
<p>a simple cycle is a cycle that repeats no vertices except that the first vertex is also the last.</p>
<p>无向图：$2e&#x3D;\sum_{i&#x3D;0}^{n-1}{d_i}$</p>
<p>有向图：e&#x3D;$\sum_{i&#x3D;0}^{n-1}{入度}&#x3D;\sum_{i&#x3D;0}^{n-1}{出度}$</p>
<p>不带回路的有向图称为有向无环图（directed acylic graph-DAG）</p>
<p>图的两种表示方法：（1）相邻矩阵法  $\Theta(|V|^2)$</p>
<p>（2）邻接表法 $\Theta(|V|+|E|)$</p>
<p>图越密集，相邻矩阵的空间效率就越高。对稀疏图使用邻接表法，空间效率高；</p>
<p>关系： $Trees \subset DAGS \subset Graphs$</p>
<h3 id="图的实现"><a href="#图的实现" class="headerlink" title="图的实现"></a>图的实现</h3><p>函数next以顶点V1和顶点V2作为输入，返回V1的所有边列表中在顶点V2之后与顶点V1关联的下一条边所对应的顶点编号。一旦访问了顶点V1中所有的边，函数next就会返回n&#x3D;|V|;</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接矩阵实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=w+<span class="number">1</span>;i&lt;numVertex;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (matrix[v][i]!=<span class="number">0</span>)</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> numVertex;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//邻接表实现</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">next</span><span class="params">(<span class="type">int</span> v,<span class="type">int</span> w)</span></span>&#123;</span><br><span class="line">	Edge it;</span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">isEdge</span>(v,w))&#123;</span><br><span class="line">		<span class="keyword">if</span> ((vertex[v]-&gt;<span class="built_in">currPos</span>()+<span class="number">1</span>)&lt;vertex[v]-&gt;<span class="built_in">length</span>())&#123;</span><br><span class="line">			vertex[v]-&gt;<span class="built_in">next</span>();</span><br><span class="line">            it=vertex[v]-&gt;<span class="built_in">getValue</span>();</span><br><span class="line">            <span class="keyword">return</span> it.<span class="built_in">vertex</span>();</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">n</span>();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="图的遍历"><a href="#图的遍历" class="headerlink" title="图的遍历"></a>图的遍历</h3><p>&#x3D;&#x3D;The graph may contain cycles, and a vertex may be reached more than one times&#x3D;&#x3D;;</p>
<h4 id="深度优先搜索（DFS）"><a href="#深度优先搜索（DFS）" class="headerlink" title="深度优先搜索（DFS）"></a>深度优先搜索（DFS）</h4><p>将生成一棵深度优先搜索树。树结构由遍历过程中所有连接新的（未被访问）顶点的边组成；</p>
<p>时间：在有向图中，DFS对每条边处理一次。在无向图中，DFS对每条边都从两个方向处理。每个顶点访问一次，时间代价：$\Theta(|V|+|E|)$</p>
<h4 id="广度优先搜索（BFS）"><a href="#广度优先搜索（BFS）" class="headerlink" title="广度优先搜索（BFS）"></a>广度优先搜索（BFS）</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">BFS</span><span class="params">(Graph* G,<span class="type">int</span> start,Queue&lt;<span class="type">int</span>&gt;* Q)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> v,w;</span><br><span class="line">    Q-&gt;<span class="built_in">enqueue</span>(start);</span><br><span class="line">    G-&gt;<span class="built_in">setMark</span>(start,visited);</span><br><span class="line">    <span class="keyword">while</span> (Q-&gt;<span class="built_in">length</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">		v=Q-&gt;<span class="built_in">dequeue</span>();</span><br><span class="line">        <span class="built_in">Previsit</span>(v);</span><br><span class="line">        <span class="keyword">for</span> (w=G-&gt;<span class="built_in">first</span>(v);w&lt;G-&gt;<span class="built_in">n</span>();w=G-&gt;<span class="built_in">next</span>(v,w))&#123;</span><br><span class="line">			<span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w)==unvisited)&#123;</span><br><span class="line">				Q-&gt;<span class="built_in">enqueue</span>(w);</span><br><span class="line">                G-&gt;<span class="built_in">setMark</span>(w,visited);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="拓扑排序"><a href="#拓扑排序" class="headerlink" title="拓扑排序"></a>拓扑排序</h3><p>&#x3D;&#x3D;如果从有向图G的每一个点均能通过深度优先搜索遍历到其他顶点，则该图是一个有环图，不存在拓扑序列；&#x3D;&#x3D;</p>
<p>只有有向无环图（DAG）才存在拓扑序列</p>
<p>两种实现方法：</p>
<p>（1）基于DFS的实现方法，在访问到该结点时什么也不做，当递归返回到该结点时，PostVisit打印该结点，结果时产生一个逆序拓扑序列；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(Graph* G)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;G-&gt;<span class="built_in">n</span>();i++)&#123;</span><br><span class="line">		G-&gt;<span class="built_in">setMark</span>(i,UNVISITED);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (i=<span class="number">0</span>;i&lt;G-&gt;<span class="built_in">n</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(i)==UNVISITED)</span><br><span class="line">            <span class="built_in">tophelp</span>(G,i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">tophelp</span><span class="params">(Graph* G,<span class="type">int</span> i)</span></span>&#123;</span><br><span class="line">	G-&gt;<span class="built_in">setMark</span>(i,visited);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> W=G-&gt;<span class="built_in">first</span>(v);W&lt;G-&gt;<span class="built_in">n</span>();w=<span class="built_in">next</span>(v,w))&#123;</span><br><span class="line">		<span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(w)==UNVISITED)</span><br><span class="line">            <span class="built_in">tophelp</span>(G,w);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printout</span>(v);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>（2）用队列代替递归实现拓扑。首先访问所有的边，计算指向每个结点的边数。将所有没有前置结点的顶点放入队列。从队列取出一个顶点时，把它打印出来，同时将其所有相邻顶点的前置条件数-1；当某个相邻结点的前置条件计数为0时，就把它放入队列。</p>
<p>拓扑排序的一个作用：当队列已经为空，但是还有结点没有被打印，则图中必然含有回路；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">topsort</span><span class="params">(Graph* G,Queue&lt;<span class="type">int</span>*&gt; Q)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> Count[G-&gt;<span class="built_in">n</span>()];</span><br><span class="line">    <span class="type">int</span> v,w;</span><br><span class="line">    <span class="keyword">for</span> (v=<span class="number">0</span>;v&lt;G-&gt;<span class="built_in">n</span>();v++)&#123;</span><br><span class="line">		Count[v]=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (v=<span class="number">0</span>;v&lt;G-&gt;<span class="built_in">n</span>();v++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> w=G-&gt;<span class="built_in">first</span>(v);w&lt;G-&gt;<span class="built_in">n</span>();w=G-&gt;<span class="built_in">next</span>(v,w))</span><br><span class="line">            Count[w]++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (v=<span class="number">0</span>;v&lt;G-&gt;<span class="built_in">n</span>();v++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (Count[v]==<span class="number">0</span>)&#123;</span><br><span class="line">			Q-&gt;<span class="built_in">enqueue</span>(v);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">while</span> (Q-&gt;<span class="built_in">length</span>()!=<span class="number">0</span>)&#123;</span><br><span class="line">		v=Q-&gt;<span class="built_in">dequeue</span>();</span><br><span class="line">        <span class="built_in">printout</span>(v);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w=<span class="built_in">first</span>(v);w&lt;G-&gt;<span class="built_in">n</span>();w=G-&gt;<span class="built_in">next</span>(v,w))&#123;</span><br><span class="line">			Count[w]--;</span><br><span class="line">            <span class="keyword">if</span> (Count[w]==<span class="number">0</span>)&#123;</span><br><span class="line">				Q-&gt;<span class="built_in">enqueue</span>(w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="单源最短路径"><a href="#单源最短路径" class="headerlink" title="单源最短路径"></a>单源最短路径</h3><p>对于无权图，用BFS就可以找到单源最短路径</p>
<p>已经处理了从顶点S出发的前i-1个顶点，称这些顶带你的集合为S，现在准备按照顺序处理第i个例子，成为顶点X，则从顶点S到X的最短路径中倒数第二个顶点一定在集合S中；<br>$$<br>d(S,X)&#x3D;min(d(S,U)+W(U,X)),U\in S<br>$$<br>Dijkstra算法</p>
<p>用到的数据结构：维护一个路径长度D(X),D中元素初始化为INFINITE，当处理一个顶点V时，它的任意一个相邻顶点X的D[x]值都可能改变；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Dijkstra算法的实现</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(Graph* G,<span class="type">int</span>* D,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> i,v;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;G-&gt;<span class="built_in">n</span>();i++)&#123;</span><br><span class="line">		v=<span class="built_in">minVertex</span>(G,D);</span><br><span class="line">        <span class="keyword">if</span> (D[v]==INFINITE) <span class="keyword">return</span> ;</span><br><span class="line">        G-&gt;<span class="built_in">setMark</span>(v,VISITED);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w=G-&gt;<span class="built_in">first</span>(v);w&lt;G-&gt;<span class="built_in">n</span>();w=G-&gt;<span class="built_in">next</span>(v,w))&#123;</span><br><span class="line">			<span class="keyword">if</span> (D[w]&gt;D[v]++G-&gt;<span class="built_in">weight</span>(v,w))&#123;</span><br><span class="line">				D[w]=D[v]+G-&gt;<span class="built_in">weight</span>(v,w);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">minVertex</span><span class="params">(Graph* G,<span class="type">int</span>* D)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> v=<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;G-&gt;<span class="built_in">n</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (G-&gt;<span class="built_in">getMark</span>(i)==UNVISITED)&#123;</span><br><span class="line">			v=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;G-&gt;<span class="built_in">n</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> ((D[i]&lt;D[V])&amp;&amp;G-&gt;<span class="built_in">getMark</span>(i)==UNVISITED)&#123;</span><br><span class="line">			v=i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> v;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间效率：$\Theta(|V|^2)$</p>
<p>第二种方法：把未处理的顶点按照距离大小顺序保存在一个最小堆中，利用$\Theta(\log(|V|))$搜索时间找到次近结点，每次修改D(X)值，通过先删除再插入的方法；</p>
<p>在密集图，当|E|接近$|V|^2$时，使用MinVertex效率高，对于稀疏图，优先队列更加有效，时间代价$\Theta((|V|+|E|)\log(|E|))$，密集图$\Theta(|V|^2\log(|V|))$</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Dijkstra</span><span class="params">(Graph* G,<span class="type">int</span>* D,<span class="type">int</span> s)</span></span>&#123;</span><br><span class="line">	DijkElem temp;</span><br><span class="line">    DijkElem E[G-&gt;<span class="built_in">e</span>()];</span><br><span class="line">    temp.distance=<span class="number">0</span>;</span><br><span class="line">    temp.vertex=s;</span><br><span class="line">    E[<span class="number">0</span>]=temp;</span><br><span class="line">    <span class="function">heap&lt;DijkElem,DDComp&gt; <span class="title">H</span><span class="params">(E,L,G-&gt;e())</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;G-&gt;<span class="built_in">n</span>();i++)&#123;</span><br><span class="line">		<span class="keyword">do</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (H.<span class="built_in">size</span>()==<span class="number">0</span>) <span class="keyword">return</span>;</span><br><span class="line">            temp=H.<span class="built_in">removefirst</span>();</span><br><span class="line">            v=temp.vertex;</span><br><span class="line">        &#125; <span class="keyword">while</span> (G-&gt;<span class="built_in">getMark</span>(v)==VISITED);</span><br><span class="line">        G-&gt;<span class="built_in">setMark</span>(v,visited);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> w=G-&gt;<span class="built_in">first</span>(v);w&lt;G-&gt;<span class="built_in">n</span>();w=G-&gt;<span class="built_in">next</span>(v,w))&#123;</span><br><span class="line">			<span class="keyword">if</span> (D[w]&gt;D[v]+G-&gt;<span class="built_in">weight</span>(v,w))&#123;</span><br><span class="line">				D[w]=D[v]+G-&gt;<span class="built_in">weight</span>(v,w);</span><br><span class="line">                temp.distance=D[w];</span><br><span class="line">                H.<span class="built_in">insert</span>(temp);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>Record the Shortest paths</p>
<p>use pre[], if pre[i]&#x3D;k, this represents the shortest path from  V<del>0</del> to V<del>i</del> is (V<del>0</del>,…,V<del>K</del>,V<del>i</del>) is the shortest path from V<del>0</del> to V<del>i</del>; The pre[i] is initiated by V<del>0</del>.</p>
<h3 id="多源最短路径"><a href="#多源最短路径" class="headerlink" title="多源最短路径"></a>多源最短路径</h3><p>时间复杂度 $\Theta(n^3)$</p>
<p>Floyd’s Algorithm</p>
<p>初始化，如果i,j有边相连，dis[i][j]&#x3D;w[i][j],否则为INFINITY]</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> k=<span class="number">1</span>;k&lt;=n;k++)&#123; <span class="comment">//枚举中间点</span></span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>;i&lt;=n;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (k!=i)&#123;</span><br><span class="line">			<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">1</span>;j&lt;=n;j++)&#123;</span><br><span class="line">				<span class="keyword">if</span> (i!=j&amp;&amp;k!=j&amp;&amp;dis[i][j]&gt;dis[i][k]+dis[k][j])&#123;</span><br><span class="line">					dis[i][j]=dis[i][k]+dis[k][j];</span><br><span class="line">                    path[i][j]=k;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211220132825.jpg"></p>
<h3 id="最小生成树（MST）"><a href="#最小生成树（MST）" class="headerlink" title="最小生成树（MST）"></a>最小生成树（MST）</h3><h4 id="Kruskal算法"><a href="#Kruskal算法" class="headerlink" title="Kruskal算法"></a>Kruskal算法</h4><p>思想：</p>
<p>贪心</p>
<p>找最小权重的边只要不构成回路</p>
<p>流程：</p>
<ol>
<li>选取边权值最小的一条，加入最小生成树</li>
<li>重复1，除非这条边产生环</li>
<li>直到所有的点都加入到最小生成树，循环结束</li>
</ol>
<h4 id="Prim算法"><a href="#Prim算法" class="headerlink" title="Prim算法"></a>Prim算法</h4><p>贪心</p>
<p>每一步都选出一条边来扩展MST，这条边是连接当前已经在MST中的&#x3D;&#x3D;某个顶点与一个不在MST中的顶点组成的边集合中代价最小的边&#x3D;&#x3D;；</p>
<p>算法流程：</p>
<ol>
<li>将点划分为U和TU两个部分，一开始TU内只有S</li>
<li>从U到TU之间所有的边中，选择一个最近的点，将其加入到TU</li>
<li>再更新U与TU之间的点的距离，继续重复2，直到所有的点都加入到TU</li>
</ol>
<p> 代码实现：</p>
<ol>
<li>使用lowCost[j]表示点j与TU的距离</li>
<li>lowCost[j]如果为0，则在TU中</li>
<li>每次取出最小的lowCost[j]，对应的点标记为k</li>
<li>如果有edge[k]  [j]小于lowCost[j],将后者更新，其实就是因为k加入了TU，所以要看k向外的所有边的长度，如果这些边的长度短于对应其他边的lowCost,则将他们的lowCost更新</li>
</ol>
<h3 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">template&lt;typename E, typename Comp&gt;</span><br><span class="line">void insertSort(E A[],int n)&#123;</span><br><span class="line">	for (int i=1;i&lt;n;i++)  //Insert i&#x27;th record;</span><br><span class="line">		for (int j=i;(j&gt;0)&amp;&amp;(Comp::prior(A[j],A[j-1]));j--)&#123;</span><br><span class="line">			swap(A,j,j-1);</span><br><span class="line">		&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最好情况：不需要移动，n-1次比较复杂度：$\Theta(n)$</p>
<p>最坏情况：比较次数：$\Theta(n^2)$</p>
<h3 id="冒泡排序"><a href="#冒泡排序" class="headerlink" title="冒泡排序"></a>冒泡排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">bubsort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j++)&#123;</span><br><span class="line">			<span class="keyword">if</span> (Comp::<span class="built_in">prior</span>(A[j],A[j<span class="number">-1</span>]))&#123;</span><br><span class="line">				<span class="built_in">swap</span>(A,j,j<span class="number">-1</span>);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="选择排序"><a href="#选择排序" class="headerlink" title="选择排序"></a>选择排序</h3><p>总的交换次数是n-1;比较次数仍然是$n^2$</p>
<p>本质上也是冒泡排序，选择最小元素的位置，最后做一次交换使它到位；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">selsort</span><span class="params">(E A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n<span class="number">-1</span>;i++)&#123;</span><br><span class="line">		<span class="type">int</span> lowindex=i;</span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=n<span class="number">-1</span>;j&gt;i;j--)&#123;</span><br><span class="line">			<span class="keyword">if</span> (Comp::<span class="built_in">prior</span>(A[j],A[lowindex]))&#123;</span><br><span class="line">				lowindex=j;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="built_in">swap</span>(A,i,lowindex);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211222165144.jpg"></p>
<h3 id="希尔排序"><a href="#希尔排序" class="headerlink" title="希尔排序"></a>希尔排序</h3><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">shellsort</span><span class="params">(E A[],<span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=n/<span class="number">2</span>;i&gt;<span class="number">2</span>;i/=<span class="number">2</span>)&#123; <span class="comment">//for each increment</span></span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=<span class="number">0</span>;j&lt;i;j++)&#123; <span class="comment">//Sort each sublist</span></span><br><span class="line">			<span class="built_in">inssort2</span>&lt;E,Comp&gt;(&amp;A[j],n-j;i);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">inssort2</span>&lt;E,Comp&gt;(A,n,<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">inssort2</span><span class="params">(E A[], <span class="type">int</span> n,<span class="type">int</span> incr)</span></span>&#123;</span><br><span class="line">	<span class="keyword">for</span> (<span class="type">int</span> i=incr;i&lt;n;i+=incr)&#123;  </span><br><span class="line">		<span class="keyword">for</span> (<span class="type">int</span> j=i;(j&gt;=incr)&amp;&amp;(Comp::<span class="built_in">prior</span>(A[j],</span><br><span class="line">             A[j-incr])); j-= incr)&#123;</span><br><span class="line">			<span class="built_in">swap</span>(A,j,j-incr);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于选择增量为3的时候，希尔排序的时间复杂度是$\Theta(n^{1.5})$</p>
<h3 id="归并排序"><a href="#归并排序" class="headerlink" title="归并排序"></a>归并排序</h3><p>伪代码</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">List <span class="title">mergesort</span><span class="params">(List inlist)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (inlist.<span class="built_in">length</span>() &lt;= <span class="number">1</span>) <span class="keyword">return</span> inlist;</span><br><span class="line">    List L1 = half of the items from the inlist;</span><br><span class="line">    List L2= ohter half of the items from the inlist;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">merge</span>(<span class="built_in">mergesort</span>(L1),<span class="built_in">mergesort</span>(L2));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>L1 contains $\ulcorner 2&#x2F;n \urcorner$ elements</p>
<p>L2 contains $\llcorner 2&#x2F;n \lrcorner$ elements</p>
<p>把排序好的子数组首先复制到辅助数组当中，然后把它们归并回原数组；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(E A[],E[] temp,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (left==right) <span class="keyword">return</span> ;</span><br><span class="line">    <span class="type">int</span> mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergesort</span>&lt;E,Comp&gt;(A,temp,left,mid);</span><br><span class="line">    <span class="built_in">mergesort</span>&lt;E,Comp&gt;(A,temp,mid,right);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=left;i&lt;=right;i++)&#123;</span><br><span class="line">		temp[i]=A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i1=left;</span><br><span class="line">    <span class="type">int</span> i2=mid+<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> curr=left;curr&lt;=right;curr++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (i1==mid+<span class="number">1</span>)</span><br><span class="line">            A[curr]=temp[i2++];</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (i2==right+<span class="number">1</span>)&#123;</span><br><span class="line">			A[curr]=temp[i1++];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (Comp::<span class="built_in">prior</span>(temp[i1],temp[i2]))&#123;</span><br><span class="line">				A[curr]=temp[i1++];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">				A[curr]=temp[i2++];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>优化：将第二个数组复制到辅助空间的时候，将顺序颠倒。让辅助数组从两端开始运行，让两个子数组的两端互相成为另一个数组的监视哨；同时用插入排序处理较短的子数组；</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">mergeSort</span><span class="params">(E A[],E[] temp,<span class="type">int</span> left,<span class="type">int</span> right)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> ((right-left) &lt;= THRESHOLD)&#123; <span class="comment">//small list</span></span><br><span class="line">    	<span class="built_in">insertsort</span>(&amp;A[left],right-left+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> i,j,k, mid=(left+right)/<span class="number">2</span>;</span><br><span class="line">    <span class="built_in">mergesort</span>&lt;E,Comp&gt;(A,temp,left,mid);</span><br><span class="line">    <span class="built_in">mergesort</span>&lt;E,Comp&gt;(A,temp,mid+<span class="number">1</span>,right);</span><br><span class="line">    <span class="keyword">for</span> (i=mid;i&gt;=left;i--) temp[i]=A[i];</span><br><span class="line">    <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;=right-mid;j++) temp[right-j+<span class="number">1</span>]=A[j+mid];</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=left,j=right,k=left;k&lt;=right;k++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (Comp::<span class="built_in">prior</span>(temp[i],temp[j])) A[k]=temp[i++];</span><br><span class="line">        <span class="keyword">else</span> A[k]=temp[j--];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>当被排序的元素的数目是n时，递归的深度是$\log(n)$, 在$log(n)$次的递归中，每一次都需要$\Theta(n)$ 的时间代价，因此总的时间代价为$\Theta(nlog(n))$; </p>
<p>最佳，平均，最差都是一样；</p>
<h3 id="快速排序"><a href="#快速排序" class="headerlink" title="快速排序"></a>快速排序</h3><p>快排需要额外的空间是因为递归时用来保存函数状态导致的，所需要的额外空间范围为log(n)~n,刚好是递归的趟数。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">qsort</span><span class="params">(E A[],<span class="type">int</span> i,<span class="type">int</span> j)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (j&lt;=i) <span class="keyword">return</span>;</span><br><span class="line">    <span class="type">int</span> pivotindex=<span class="built_in">findpivot</span>(A,i,j);</span><br><span class="line">    <span class="built_in">swap</span>(A,pivotindex,j);</span><br><span class="line">    <span class="type">int</span> k=<span class="built_in">partition</span>&lt;E,Comp&gt;(A,i<span class="number">-1</span>,j,A[j]); <span class="comment">//k是划分后右半部分的起始位置</span></span><br><span class="line">    <span class="built_in">swap</span>(A,k,j);</span><br><span class="line">    <span class="built_in">qsort</span>&lt;E,Comp&gt;(A,i,k<span class="number">-1</span>);</span><br><span class="line">    <span class="built_in">qsort</span>&lt;E,Comp&gt;(A,k,j);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> Comp&gt;</span><br><span class="line"><span class="function"><span class="keyword">inline</span> <span class="type">int</span> <span class="title">partition</span><span class="params">(E A[], <span class="type">int</span> l,<span class="type">int</span> r,E&amp; pivot)</span></span>&#123;</span><br><span class="line">	<span class="keyword">do</span>&#123;</span><br><span class="line">		<span class="keyword">while</span> (Comp::<span class="built_in">prior</span>(A[++l],pivot));</span><br><span class="line">        <span class="keyword">while</span> ((l&lt;r) &amp;&amp; Comp::<span class="built_in">prior</span>(pivot,A[--r]));</span><br><span class="line">        <span class="built_in">swap</span>(A,l,r);</span><br><span class="line">    &#125; <span class="keyword">while</span> (l&lt;r);</span><br><span class="line">    <span class="keyword">return</span> l;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>最差情况下：$\Theta(n^2)$</p>
<p>最好与平均情况下：$\Theta(nlog(n))$</p>
<p>判断快排序列是否正确</p>
<p>每经过一次快排，轴点元素必然就位。也就是说，一趟下来至少有一个元素在最终位置</p>
<p>第一趟，确定一个最终位置</p>
<p>第二趟排序：又确定一个或者两个元素位置</p>
<ul>
<li>当第一趟确认的位置在最左或者最右的时候，第二趟排序只能确定一个位置</li>
<li>当第一趟元素确认位置不是最左或者最右时，第二趟能确认两个位置</li>
</ul>
<h3 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h3><p>从小到大排序建立大根堆 将n-1个元素全部removefirst();</p>
<p>从大到小排序建立小根堆</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">heapsort</span><span class="params">(E A[], <span class="type">int</span> n)</span></span>&#123;</span><br><span class="line">	E maxval;</span><br><span class="line">    <span class="function">heap&lt;E,comp&gt; <span class="title">H</span><span class="params">(A,n,n)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">		maxval=H.<span class="built_in">removefirst</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>建堆（O(n))  removefirst(O(log(n))  So the cost of heapsort in the worst, average, and the best cases O(nlog(n));</p>
<h3 id="Binsort"><a href="#Binsort" class="headerlink" title="Binsort"></a>Binsort</h3><p>B[]箱子  根据A[i]的值排入对应的箱子</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">for (int i=0;i&lt;n;i++)&#123;</span><br><span class="line">	B[A[i]]=A[i];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>时间复杂度（n） </p>
<p>扩展：<br>(1).allow duplicate values among keys（每一个数组代表一个链表）</p>
<p>(2).allow a key range greater than n </p>
<p>questions : A[]&#x3D;{1,100000011}; MAXSIZE过大</p>
<h3 id="Bucket-Sort"><a href="#Bucket-Sort" class="headerlink" title="Bucket Sort"></a>Bucket Sort</h3><p>基本思想：桶内放入的值不一定的相同。</p>
<p>52张扑克牌排序：花色（高位），面值（地位） 花色相同再根据面值排序</p>
<p>按照花色分配之后，收尾排序（任意一种排序方法）</p>
<p>数字排序：桶的个数与数字的基数有关</p>
<h3 id="Radix-Sort"><a href="#Radix-Sort" class="headerlink" title="Radix Sort"></a>Radix Sort</h3><p>按照个位向高位不断排序，分配收集一次则一位排序完成</p>
<p>LSD低位优先，分配排序地位优先</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E,<span class="keyword">typename</span> getKey&gt;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">radix</span><span class="params">(E A[],E B[],<span class="type">int</span> n,<span class="type">int</span> k,<span class="type">int</span> r,<span class="type">int</span> cnt[])</span></span>&#123;</span><br><span class="line"><span class="comment">//cnt[i] stores number of records in bin[i]</span></span><br><span class="line">    <span class="type">int</span> j;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>; rtoi=<span class="number">1</span>; i&lt;k; i++, rtoi*=r)&#123;</span><br><span class="line">		<span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;r;j++) cnt[j]=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;r;j++)</span><br><span class="line">        	cnt[(getKey::<span class="built_in">key</span>(A[j])/rtoi)%r]++;</span><br><span class="line"><span class="comment">//Index B: cnt[j] will be index for last slot of bin j.</span></span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">1</span>;j&lt;r;j++) cnt[j]=cnt[j<span class="number">-1</span>]+cnt[j];</span><br><span class="line">        <span class="keyword">for</span> (j=n<span class="number">-1</span>;j&gt;=<span class="number">0</span>;j--)</span><br><span class="line">            B[--cnt[(getKey::<span class="built_in">key</span>(A[j])/rtoi)%r]]=A[j];</span><br><span class="line">        <span class="keyword">for</span> (j=<span class="number">0</span>;j&lt;n;j++) A[j]=B[j];</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="排序总结"><a href="#排序总结" class="headerlink" title="排序总结"></a>排序总结</h3><p>简单排序中只有插入排序有最好情况(n);</p>
<p>基数排序  o(n)；</p>
<p>用到额外的空间： 快排，合并排序， 基数排序 （非就地排序）</p>
<p>稳定的排序： 先进排序中只有合并排序稳定</p>
<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211223152508.jpg"></p>
<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211223152557.jpg"></p>
<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211223153454.jpg"></p>
<p>复杂排序中只有合并排序是稳定的</p>
<h2 id="查找"><a href="#查找" class="headerlink" title="查找"></a>查找</h2><p>线性查找</p>
<p>hash表查找</p>
<p>树索引查找（BST）</p>
<p>问题：线性查找无序数组，找到最大值和最小值，比较次数不超过1.5n次；</p>
<p>解答：每次与A中的两个元素比较，每次循环做3次比较</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">maxMinValue</span><span class="params">(E A[],<span class="type">int</span> n,<span class="type">int</span>&amp; maxp,<span class="type">int</span>&amp; minp)</span></span>&#123;</span><br><span class="line">	maxp=minp=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> k=n&amp;<span class="number">1</span>;k&lt;n;k+=<span class="number">2</span>)&#123;</span><br><span class="line">		<span class="keyword">if</span> (A[K]&lt;A[k+<span class="number">1</span>])&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[k]&lt;A[minp])&#123;</span><br><span class="line">				minp=k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (A[k+<span class="number">1</span>]&gt;A[maxp])&#123;</span><br><span class="line">				maxp=k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span>&#123;</span><br><span class="line">			<span class="keyword">if</span> (A[k]&gt;A[maxp])&#123;</span><br><span class="line">				maxp=k;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span> (A[k+<span class="number">1</span>]&lt;A[minp])&#123;</span><br><span class="line">				minp=k+<span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h3 id="折半查找"><a href="#折半查找" class="headerlink" title="折半查找"></a>折半查找</h3><p>最坏需要查找多少次？   &#x3D;&#x3D;在两个次方范围之间取大的&#x3D;&#x3D;</p>
<p>查找一个元素需要多少次？   画树，位置决定查找次数</p>
<p>折半查找的时候，如果总次数是奇数，那么是剩余的次数应该是$\ulcorner n&#x2F;2 \urcorner$次</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">binary</span><span class="params">(<span class="type">int</span> A[],<span class="type">int</span> n,<span class="type">int</span> k)</span></span>&#123;</span><br><span class="line">	<span class="type">int</span> l=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> r=n;</span><br><span class="line">    <span class="keyword">while</span> (l+<span class="number">1</span>!=r)&#123;</span><br><span class="line">		<span class="type">int</span> i=(l+r)/<span class="number">2</span>;</span><br><span class="line">        <span class="keyword">if</span> (K&lt;A[i]) r=i;</span><br><span class="line">        <span class="keyword">if</span> (K==A[i]) <span class="keyword">return</span> i;</span><br><span class="line">        <span class="keyword">if</span> (K&gt;A[i]) l=i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> n; <span class="comment">//the searched value is not in A</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="二分问题的应用"><a href="#二分问题的应用" class="headerlink" title="二分问题的应用"></a>二分问题的应用</h4><p>山峰数组</p>
<p>原理：<br><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211223161537.jpg"></p>
<p>代码：<br><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211223161625.jpg"></p>
<p><img src="D:\大二学习\数据结构\Typora_pic\QQ截图20211223165553.jpg"></p>
<p>两个升序序列 a[1…n],b[1…m], 查找合并后的中位数，即排在$[\frac{m+n}{2}]$位的元素；</p>
<ul>
<li>归并，时间复杂度 $\Theta(\frac{m+n}{2}])$</li>
</ul>
<h3 id="Hash表查找"><a href="#Hash表查找" class="headerlink" title="Hash表查找"></a>Hash表查找</h3><h4 id="使用桶散列进行搜索"><a href="#使用桶散列进行搜索" class="headerlink" title="使用桶散列进行搜索"></a>使用桶散列进行搜索</h4><p>（1）to hash the key to determine which bucket should contain the keys. The records in this bucket are then searched</p>
<p>（2）if the desired key value is not founded and the bucket still has free slots, then the search is complete.</p>
<p>（3）if the bucket is full, then it is possible that the desired record is stored in the overflow bucket. In this case, the overflow bucket must be searched until the record is founded or all records in the overflow bucket have been checked. If many records are in the overflow bucket, this will be an expensive process.</p>
<h4 id="Insertion-method-for-a-dictionary-implemented-by-a-hash-table"><a href="#Insertion-method-for-a-dictionary-implemented-by-a-hash-table" class="headerlink" title="Insertion method for a dictionary implemented by a hash table"></a>Insertion method for a dictionary implemented by a hash table</h4><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> Key,<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="type">void</span> hashdict&lt;Key,E&gt;::<span class="built_in">hashInsert</span>(<span class="type">const</span> Key&amp; k,<span class="type">const</span> E&amp; e)&#123;</span><br><span class="line">	<span class="type">int</span> home;   <span class="comment">//home position for e</span></span><br><span class="line">    <span class="type">int</span> pos=home=<span class="built_in">h</span>(k);   <span class="comment">//init probe sequence</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">1</span>; EMPTYKEY != (HT[pos]).<span class="built_in">key</span>();i++)&#123;</span><br><span class="line">		pos=(home+<span class="built_in">p</span>(k,i)) % M;</span><br><span class="line">        <span class="built_in">Assert</span>(k!= (HT[pos]).<span class="built_in">key</span>()),<span class="string">&quot;Duplicates not allowed&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">KVpair&lt;Key,E&gt; <span class="title">temp</span><span class="params">(k,e)</span></span>;</span><br><span class="line">    HT[pos] = temp;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>The simplest probe function: p(k,i)&#x3D;i;</p>
<h4 id="Problem-of-linear-probing"><a href="#Problem-of-linear-probing" class="headerlink" title="Problem of linear probing"></a>Problem of linear probing</h4><p>（1）primary clustering;</p>
<p>（2）small clusters tend to merge into big clusters, making the problem worse;</p>
<p>（3）primary clustering leads to long probe sequences;</p>
<h4 id="Solutions"><a href="#Solutions" class="headerlink" title="Solutions"></a>Solutions</h4><p>Linear probing with skiping:  hi(x)&#x3D;(h(x)+ic)%M;</p>
<p>（1）c constant other than 1;</p>
<p>（2）records with adjacent home buckets will not follow same probe sequence</p>
<p>Random probing：hi(x)&#x3D;(h(x)+r<del>i</del>)%M;</p>
<p>r<del>i</del> is the ith value in a random permutation of numbers from 1 to M-1;</p>
<p>insertion s and searches use the same sequence of  “random” numbers;</p>
<p>处理冲突的方法：</p>
<ol>
<li>开散列法：拉链法（数组内存储元素，与图的邻接表法表示不同）</li>
<li>闭散列法： <ul>
<li>桶式散列法</li>
<li>线性探测法</li>
</ul>
</li>
</ol>
<p>线性勘测法的平均查找长度：</p>
<p>查找成功：<br>$$<br>\frac {\sum 结点的比较次数之和}{散列表存储元素个数}<br>$$<br>查找失败：<br>$$<br>\frac {从0-(P-1)个结点查找失败的比较次数}{选取的P}<br>$$</p>
<h2 id="homework"><a href="#homework" class="headerlink" title="homework"></a>homework</h2><p>单链表为空只有头节点</p>
<p>叶结点前序中序遍历不变</p>
<p>度为2 的结点，度为1的结点，问叶子结点：叶结点始终等于度为2的结点加1</p>
<p>n2+n1+n0&#x3D;n;</p>
<p>2n2+n1&#x3D;n-1;</p>
<p>二叉树的最长路径问题：一定有一个是叶节点</p>
<p>解决方法：对任何一个节点，求它的左边子树与右边子树高度之和</p>
<p>二叉树转换为双链表：把左边子树转换为一个双链表</p>
<p>二叉搜索树：n-1,n+1在同一层，n一定是他们的祖先，但不一定是他们的父节点；</p>
<p>1025个结0点，最好的最坏，这棵树最接近完整，1023个结点时完整的二叉树，下面挂了两个叶节点。最坏的最坏，线性结构1025；</p>
<p>BST的后序遍历是否合理：（1）给出中序遍历结果画出树</p>
<p>（2）快排原理</p>
<p>投资：单调栈保留之前买好的股票，栈顶最小值（线性时间）</p>
<p>光是左子树根节点比该节点小，右子树根节点比该节点大不一定是二叉搜索树</p>
<p>在二叉搜索树同一层，都有LCA（共同公共祖先）,所有左边的一定小于右边的。</p>
<p>删除BST结点：找右边的最小结点或者左边的最大结点替换；</p>
<p>括号字符串的移位操作：最低点抬高</p>
<p>关节点：这个点去掉图不连通</p>
<p>&#x3D;&#x3D;最小生成树V1到V2的路径不一定是它们之间的最短路径&#x3D;&#x3D;</p>
<p>最短路径条数初始化时，count[S]&#x3D;1,其余Vcount[V]&#x3D;0;</p>
<p>对N个记录进行归并排序，归并躺数N；</p>
<p>书上折半查找指针都在外面</p>
<h3 id="二叉树编程"><a href="#二叉树编程" class="headerlink" title="二叉树编程"></a>二叉树编程</h3><p>求二叉树上第k层的结点个数</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">int</span> <span class="title">NumberOfLevel</span><span class="params">(BSTNode* root, <span class="type">int</span> obj)</span></span>&#123;</span><br><span class="line">	BSTNode* res[<span class="number">10001</span>];</span><br><span class="line">    <span class="type">int</span> first=<span class="number">-1</span>; <span class="type">int</span> last=<span class="number">-1</span>;</span><br><span class="line">    <span class="type">int</span> level=<span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> latest=<span class="number">0</span>;</span><br><span class="line">    res[++last]=root;</span><br><span class="line">    <span class="keyword">while</span> (first&lt;last)&#123;</span><br><span class="line">        <span class="keyword">if</span> (level==obj)&#123;</span><br><span class="line">			<span class="keyword">return</span> last-first;</span><br><span class="line">        &#125;</span><br><span class="line">		BSTNode* temp=res[++first];</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;left)&#123;</span><br><span class="line">			res[++last]=temp-&gt;left;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;right)&#123;</span><br><span class="line">			res[++last]=temp-&gt;right;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (latest==first)&#123;</span><br><span class="line">			latest=last;</span><br><span class="line">            level++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//递归算法</span></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">NumberOfValue</span><span class="params">(BSTNode* root,<span class="type">int</span> obj)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">nullptr</span>||obj==<span class="number">0</span>)&#123;</span><br><span class="line">    	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (obj==<span class="number">1</span>)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">NumberOfValue</span>(root-&gt;left,obj<span class="number">-1</span>)+<span class="built_in">NumberOfValue</span>(root-&gt;right,obj<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>二叉树的最长路径问题</p>
<p>求出任意两个结点之间的路径长度</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">template</span> &lt;<span class="keyword">typename</span> E&gt;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">LongestPathInBinaryTree</span><span class="params">(BinNode&lt;E&gt;* root, <span class="type">int</span>&amp; max_dist)</span></span>&#123;</span><br><span class="line">	queue&lt;BinNode&lt;E&gt;*&gt; rt;</span><br><span class="line">    rt.<span class="built_in">enqueue</span>(root);</span><br><span class="line">    <span class="keyword">while</span> (!rt.<span class="built_in">empty</span>())&#123;</span><br><span class="line">		BinNode&lt;E&gt;* temp=rt-&gt;<span class="built_in">dequeue</span>();</span><br><span class="line">        <span class="type">int</span> maxh=<span class="built_in">longest</span>(temp);</span><br><span class="line">        <span class="keyword">if</span> (maxh&gt;max_dist)&#123;</span><br><span class="line">			max_dist=maxh;</span><br><span class="line">        &#125;</span><br><span class="line">        </span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;left)&#123;</span><br><span class="line">			rt.<span class="built_in">enqueue</span>(root-&gt;left);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (temp-&gt;right)&#123;</span><br><span class="line">			rt.<span class="built_in">enqueue</span>(root-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> max_dist;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">longest</span><span class="params">(BinNode&lt;E&gt;* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> r=<span class="built_in">getheight</span>(root-&gt;right);</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">getheight</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> l+r;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">getheight</span><span class="params">(BinNode&lt;E&gt;* root)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="type">int</span> r=<span class="built_in">getheight</span>(root-&gt;right);</span><br><span class="line">    <span class="type">int</span> l=<span class="built_in">getheight</span>(root-&gt;left);</span><br><span class="line">    <span class="keyword">return</span> ((l&gt;r)? l:r)+<span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="是否为同一棵二叉搜索树"><a href="#是否为同一棵二叉搜索树" class="headerlink" title="是否为同一棵二叉搜索树"></a>是否为同一棵二叉搜索树</h6><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">bool</span> <span class="title">isSameTree</span><span class="params">(BSTNode* root1,BSTNode* root2)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (root1==<span class="literal">NULL</span>&amp;&amp;root2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (root1==<span class="literal">NULL</span>||root2==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">if</span> (root1-&gt;data==root2-&gt;data)&#123;</span><br><span class="line">			<span class="keyword">return</span> <span class="built_in">isSameTree</span>(root1-&gt;left,root2-&gt;left)&amp;&amp;<span class="built_in">isSameTree</span>(root1-&gt;right,root2-&gt;right);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>给定BST的先序遍历，求BST上两个点最近的公共祖先</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">BSTNode* <span class="title">build</span><span class="params">(<span class="type">int</span>* pre,<span class="type">int</span>* in,<span class="type">int</span> len)</span></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (len&lt;<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">    BSTNode* root=pre[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> k=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i=<span class="number">0</span>;i&lt;len;i++)&#123;</span><br><span class="line">		<span class="keyword">if</span> (in[i]==pre[<span class="number">0</span>])&#123;</span><br><span class="line">			k=i;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    root-&gt;left=<span class="built_in">build</span>(pre+<span class="number">1</span>,in,k);</span><br><span class="line">    root-&gt;right=<span class="built_in">build</span>(pre+k+<span class="number">1</span>;in+k+<span class="number">1</span>;len-k<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">return</span> root;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BSTNode* <span class="title">findLCA</span><span class="params">(BSTNode* root,data1,data2)</span></span>&#123;</span><br><span class="line">   <span class="keyword">if</span> (root-&gt;data==data1||root-&gt;data==data2)&#123;</span><br><span class="line">        <span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">	<span class="type">bool</span> isleft_1=<span class="built_in">find</span>(root-&gt;left,data1);</span><br><span class="line">    <span class="type">bool</span> isleft_2=<span class="built_in">find</span>(root-&gt;left,data2);</span><br><span class="line">    <span class="comment">//首先判断它们是否都在左子树当中</span></span><br><span class="line">    <span class="keyword">if</span> (isleft_1&amp;&amp;isleft_2)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">findLCA</span>(root-&gt;left,data1,data2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isleft_1&amp;&amp;!isleft_2)&#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="built_in">findLCA</span>(root-&gt;right,data1,data2);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">		<span class="keyword">return</span> root;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


    </div>

    
        <hr class="fhr">
        <div id="vcomments"></div>
    
</div>
    <div class="footer" id="footer">
    <p><h4>Copyright © 2020 | Author: LiuXunzhuo | Theme By <a class="theme-author" target="_blank" rel="noopener" href="https://github.com/Xunzhuo/hexo-theme-coder" style="font-size:14px; color: #969696">Coder</a></h4>
    <label class="el-switch el-switch-blue el-switch-sm" style="vertical-align: sub;">
        <input type="checkbox" name="switch" id="update_style">
        <span class="el-switch-style"></span>
    </label>
    <!--         <script type="text/javascript">
    var cnzz_protocol = (("https:" == document.location.protocol) ? "https://" : "http://");
    document.write(unescape("%3Cspan id='cnzz_stat_icon_1278548644'%3E%3C/span%3E%3Cscript src='" + cnzz_protocol + "v1.cnzz.com/stat.php%3Fid%3D1278548644%26show%3Dpic1' type='text/javascript'%3E%3C/script%3E"));
    </script> -->
</p>
</div>
<input type="hidden" id="web_style" value="light">
<input type="hidden" id="valine_appid" value="NOsswOncKgc8HOxqo9oxIWlX-gzGzoHsz">
<input type="hidden" id="valine_appKey" value="z1FihjWEbS8uIfUQdmCtK7zz">

<script src="/libs/jquery.min.js"></script>


<script src="/libs/highlight/highlight.pack.js"></script>

<script src='//cdn.jsdelivr.net/npm/valine@1.3.10/dist/Valine.min.js'></script>

<script src="/js/js.js"></script>

<style type="text/css">
.v * {
color: #698fca;
}
.v .vlist .vcard .vhead .vsys {
color: #3a3e4a;
}
.v .vlist .vcard .vh .vmeta .vat {
color: #638fd5;
}
.v .vlist .vcard .vhead .vnick {
color: #6ba1ff;
}
.v a {
color: #8696b1;
}
.v .vlist .vcard .vhead .vnick:hover {
color: #669bfc;
}
</style>
    <script type="text/javascript" color="173,174,173" opacity='1' zIndex="-2" count="99" src="//cdn.bootcss.com/canvas-nest.js/1.0.0/canvas-nest.min.js"></script>
</body>
</html>
